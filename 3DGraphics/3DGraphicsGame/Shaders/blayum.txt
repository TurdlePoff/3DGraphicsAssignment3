#include "Camera.h"

CCamera* CCamera::s_pCameraInstance = 0;

CCamera::CCamera()
{
	float iWidthScaled = SCR_WIDTH / 200;
	float iHeightScaled = SCR_HEIGHT / 200;
	projection = glm::ortho(-iWidthScaled, iWidthScaled, -iHeightScaled, iHeightScaled, 0.0f, 100.0f);

	//projection = glm::perspective(45.0f, (GLfloat)iWidthScaled / (GLfloat)iHeightScaled, 0.1f, 100.0f);//(-iWidthScaled, iWidthScaled, -iHeightScaled, iHeightScaled, 0.0f, 100.0f);
}


CCamera* CCamera::GetInstance()
{
	if (s_pCameraInstance == 0)
	{
		s_pCameraInstance = new CCamera();
	}
	return s_pCameraInstance;
}

void CCamera::SetMVP(glm::vec3 _trans, glm::vec3 _scale, glm::vec3 _rot)
{
	glm::mat4 translate = glm::translate(glm::mat4(), _trans);
	glm::mat4 rotation = glm::rotate(glm::mat4(), glm::radians(_rot.x), glm::vec3(1, 0, 0));
	rotation = glm::rotate(rotation, glm::radians(_rot.z), glm::vec3(0, 1, 0));
	rotation = glm::rotate(rotation, glm::radians(_rot.y), glm::vec3(0, 0, 1));
	glm::mat4 scale = glm::scale(glm::mat4(), _scale);

	glm::mat4 Model = translate * rotation * scale;
	//Model = glm::rotate(Model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));

	view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

	glm::mat4 MVP = projection * view * Model;
	glUseProgram(Utils::programTextured);

	GLint MVPLoc = glGetUniformLocation(Utils::programTextured, "MVP");
	glUniformMatrix4fv(MVPLoc, 1, GL_FALSE, glm::value_ptr(MVP));
}

void CCamera::Set3DMVP(glm::vec3 _trans, glm::vec3 _scale, glm::vec3 _rot)
{
	float iWidthScaled = SCR_WIDTH / 200;
	float iHeightScaled = SCR_HEIGHT / 200;

	glm::mat4 translate = glm::translate(glm::mat4(), _trans);
	glm::mat4 rotation = glm::rotate(glm::mat4(), glm::radians(_rot.x), glm::vec3(1, 0, 0));
	rotation = glm::rotate(rotation, glm::radians(_rot.z), glm::vec3(0, 1, 0));
	rotation = glm::rotate(rotation, glm::radians(_rot.y), glm::vec3(0, 0, 1));
	glm::mat4 scale = glm::scale(glm::mat4(), _scale);

	glm::mat4 Model = translate * rotation * scale;


	glm::mat4 view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
	glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)(iWidthScaled / iHeightScaled), 0.1f, 100.0f);

	glm::mat4 MVP = projection * view * Model;
	glUseProgram(Utils::programTextured);
	GLint MVPLoc = glGetUniformLocation(Utils::programTextured, "MVP");
	glUniformMatrix4fv(MVPLoc, 1, GL_FALSE, value_ptr(MVP));

	//float currentTime = glutGet(GLUT_ELAPSED_TIME);
	//currentTime = currentTime * 0.001f;

	//GLfloat camHeight = 2.0f;
	//GLfloat radius = 4.0f;
	//GLfloat camX = sin(currentTime) * radius; // Rotating the Camera around
	//GLfloat camZ = cos(currentTime) * radius; // the 3D object

	//glm::mat4 model = glm::mat4();// Identity Mat for object to be at origin with no rotation/Scaling
	//view = glm::lookAt(glm::vec3(camX, camHeight, camZ), glm::vec3(0.0f, 0.0f, 0.0f),
	//	glm::vec3(0.0f, 1.0f, 0.0f));
	
}

void CCamera::SetCamFront(glm::vec3 _cFront)
{
	cameraFront = _cFront;
}

void CCamera::SetCamPos(glm::vec3 _cPos)
{
	cameraPos = _cPos;
}

void CCamera::SetCamUp(glm::vec3 _cUp)
{
	cameraUp = _cUp;
}

void CCamera::SetCamSpeed(float _cSpeed)
{
	cameraSpeed = _cSpeed;
}

glm::vec3 CCamera::GetCamFront()
{
	return cameraFront;
}

glm::vec3 CCamera::GetCamPos()
{
	return cameraPos;
}

glm::vec3 CCamera::GetCamUp()
{
	return cameraUp;
}

float CCamera::GetCamSpeed()
{
	return cameraSpeed;
}
